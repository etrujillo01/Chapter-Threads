"""
‚ö° SESI√ìN 3: Gu√≠a Completa de Async/Await

Esta gu√≠a consolidada cubre TODOS los aspectos de async/await en Python:
- ¬øPor qu√© async es "especial"?
- ¬øC√≥mo sabemos que NO hay race conditions?
- Comparaci√≥n completa: Threading vs Multiprocessing vs Async
- Gu√≠as pr√°cticas de decisi√≥n

üéØ Objetivos:
- Entender la "magia" de async/await
- Demostrar matem√°ticamente la ausencia de race conditions
- Comparar los 3 enfoques de concurrencia
- Crear criterios claros para elegir cada uno
"""

import time
import threading
import multiprocessing as mp
import asyncio
import concurrent.futures
import math
from typing import List, Dict

# ============================================================================
# ü™Ñ PARTE 1: ¬øPOR QU√â ASYNC ES "M√ÅGICO"?
# ============================================================================

print("ü™Ñ" + "="*70)
print("ü™Ñ PARTE 1: ¬øPor qu√© Async es 'm√°gico'?")
print("="*70)

def explain_paradigm_difference():
    """Explicar la diferencia fundamental de paradigmas"""
    print("\nüéØ DIFERENCIA FUNDAMENTAL DE PARADIGMAS:")
    print("="*50)
    
    print("üßµ THREADING = Concurrencia PREEMPTIVA:")
    print("   ‚Ä¢ OS decide cu√°ndo cambiar threads ‚Üí IMPREDECIBLE")
    print("   ‚Ä¢ M√∫ltiples threads reales ejecutando")
    print("   ‚Ä¢ ~8MB memoria por thread")
    print("   ‚Ä¢ M√°ximo pr√°ctico: ~5,000 threads")
    print("   ‚Ä¢ Race conditions POSIBLES")
    
    print("\n‚ö° ASYNC = Concurrencia COOPERATIVA:")
    print("   ‚Ä¢ C√≥digo decide cu√°ndo ceder control ‚Üí PREDECIBLE")
    print("   ‚Ä¢ Un solo thread con m√∫ltiples corrutinas")
    print("   ‚Ä¢ ~1KB memoria por corrutina")
    print("   ‚Ä¢ M√°ximo pr√°ctico: ~100,000+ corrutinas")
    print("   ‚Ä¢ Race conditions IMPOSIBLES")

def demo_scalability_difference():
    """Demostrar diferencias de escalabilidad"""
    print("\nüî• DIFERENCIAS DE ESCALABILIDAD:")
    print("="*50)
    
    tasks_scenarios = [10, 100, 1000, 10000]
    
    print("üìä COMPARACI√ìN DE RECURSOS:")
    for tasks in tasks_scenarios:
        threading_ram = tasks * 8  # MB
        async_ram = tasks / 1024   # MB (convertir de KB)
        
        print(f"\n   {tasks:,} tareas concurrentes:")
        print(f"     üßµ Threading: ~{threading_ram:,}MB RAM")
        print(f"     ‚ö° Async: ~{async_ram:.1f}MB RAM")
        
        if threading_ram > 1024:  # > 1GB
            print(f"     ‚ö†Ô∏è  Threading: {threading_ram/1024:.1f}GB RAM!")
        if tasks >= 5000:
            print(f"     ‚ùå Threading: L√≠mite pr√°ctico excedido")

# ============================================================================
# üîç PARTE 2: PRUEBA DEFINITIVA - NO HAY RACE CONDITIONS
# ============================================================================

print("\nüîç" + "="*70)
print("üîç PARTE 2: PRUEBA DEFINITIVA - NO hay Race Conditions")
print("="*70)

def demonstrate_threading_race_conditions():
    """Demostrar race conditions en threading"""
    print("\nüßµ THREADING: Intentando provocar race conditions...")
    
    shared_counter = 0
    
    def unsafe_increment():
        """Incrementar de manera no segura"""
        nonlocal shared_counter
        for _ in range(1000):
            # üö® OPERACI√ìN NO AT√ìMICA: Read-Modify-Write
            old_value = shared_counter    # READ
            new_value = old_value + 1     # MODIFY
            shared_counter = new_value    # WRITE
            
            # Aumentar probabilidad de race condition
            if _ % 100 == 0:
                time.sleep(0.001)
    
    # Ejecutar m√∫ltiples tests
    race_detected = False
    for test in range(5):
        shared_counter = 0
        
        threads = []
        for _ in range(2):
            thread = threading.Thread(target=unsafe_increment)
            threads.append(thread)
            thread.start()
        
        for thread in threads:
            thread.join()
        
        expected = 2000
        actual = shared_counter
        
        if actual != expected:
            print(f"   ‚ùå Test {test+1}: {actual} (Esperado: {expected}) - Race condition detectado!")
            print(f"      üîç Perdimos {expected - actual} operaciones")
            race_detected = True
            break
        else:
            print(f"   ‚úÖ Test {test+1}: {actual} (Correcto esta vez)")
    
    if not race_detected:
        print("   üí° No se detect√≥ race condition, pero PUEDE ocurrir")

async def demonstrate_async_no_race_conditions():
    """Demostrar que async NO puede tener race conditions"""
    print("\n‚ö° ASYNC: Intentando provocar race conditions...")
    
    shared_counter = 0
    
    async def safe_increment():
        """Incrementar en async - siempre seguro"""
        nonlocal shared_counter
        for _ in range(1000):
            # ‚úÖ MISMA OPERACI√ìN: Read-Modify-Write
            old_value = shared_counter    # READ
            new_value = old_value + 1     # MODIFY
            shared_counter = new_value    # WRITE
            
            # Ceder control ocasionalmente (voluntario)
            if _ % 100 == 0:
                await asyncio.sleep(0.001)  # Solo AQU√ç puede cambiar corrutina
    
    # Ejecutar m√∫ltiples tests
    for test in range(5):
        shared_counter = 0
        
        # Ejecutar dos corrutinas concurrentemente
        await asyncio.gather(
            safe_increment(),
            safe_increment()
        )
        
        expected = 2000
        actual = shared_counter
        
        print(f"   ‚úÖ Test {test+1}: {actual} (Esperado: {expected}) - ¬°SIEMPRE correcto!")

def explain_why_async_is_safe():
    """Explicar t√©cnicamente por qu√© async es seguro"""
    print("\nüî¨ AN√ÅLISIS T√âCNICO: ¬øPor qu√© async es diferente?")
    print("="*60)
    
    print("üßµ THREADING - Problema:")
    print("   1. Thread 1: old_value = shared.value  # Lee 100")
    print("   2. ‚ö†Ô∏è  OS INTERRUMPE AQU√ç ‚ö†Ô∏è")
    print("   3. Thread 2: old_value = shared.value  # Lee 100 (¬°mismo valor!)")
    print("   4. Thread 2: shared.value = 101        # Escribe 101")
    print("   5. Thread 1: shared.value = 101        # Escribe 101 (perdi√≥ T2)")
    print("   üìä Resultado: 101 en lugar de 102 ‚ùå")
    
    print("\n‚ö° ASYNC - Soluci√≥n:")
    print("   1. Corrutina 1: old_value = shared.value  # Lee 100")
    print("   2. Corrutina 1: new_value = 101           # Calcula")
    print("   3. Corrutina 1: shared.value = 101        # Escribe")
    print("   4. ‚úÖ SOLO AQU√ç puede ceder: await asyncio.sleep()")
    print("   5. Corrutina 2: old_value = shared.value  # Lee 101 (correcto)")
    print("   6. Corrutina 2: shared.value = 102        # Escribe 102")
    print("   üìä Resultado: 102 (siempre correcto) ‚úÖ")
    
    print("\nüéØ PRINCIPIOS CLAVE DE ASYNC:")
    print("   ‚úÖ Un solo thread ‚Üí No competencia por recursos")
    print("   ‚úÖ Control se cede SOLO en 'await' ‚Üí Puntos expl√≠citos")
    print("   ‚úÖ Operaciones entre 'awaits' son AT√ìMICAS")
    print("   ‚úÖ Event loop garantiza ejecuci√≥n secuencial")

# ============================================================================
# üìä PARTE 3: COMPARACI√ìN COMPLETA DE RENDIMIENTO
# ============================================================================

print("\nüìä" + "="*70)
print("üìä PARTE 3: COMPARACI√ìN COMPLETA DE RENDIMIENTO")
print("="*70)

# Funciones de simulaci√≥n I/O-bound
def simulate_io_task_sync(task_name: str, delay: float = 1.0) -> Dict:
    """Simula tarea I/O-bound sincr√≥nicamente"""
    time.sleep(delay)
    return {
        'task': task_name,
        'status': 'completed', 
        'delay': delay,
        'method': 'sync'
    }

def simulate_io_task_thread(task_name: str, delay: float = 1.0) -> Dict:
    """Simula tarea I/O-bound en thread"""
    time.sleep(delay)
    return {
        'task': task_name,
        'status': 'completed',
        'delay': delay, 
        'method': 'threading'
    }

async def simulate_io_task_async(task_name: str, delay: float = 1.0) -> Dict:
    """Simula tarea I/O-bound as√≠ncronamente"""
    await asyncio.sleep(delay)
    return {
        'task': task_name,
        'status': 'completed',
        'delay': delay,
        'method': 'async'
    }

# Funciones de simulaci√≥n CPU-bound  
def count_primes_in_range(start: int, end: int) -> Dict:
    """Cuenta n√∫meros primos en un rango (CPU-bound)"""
    def is_prime(n):
        if n < 2:
            return False
        for i in range(2, int(math.sqrt(n)) + 1):
            if n % i == 0:
                return False
        return True
    
    count = sum(1 for n in range(start, end) if is_prime(n))
    return {
        'range': f'{start}-{end}',
        'primes': count,
        'method': 'cpu_task'
    }

# Tests de comparaci√≥n
def test_sequential_io(tasks: List[str]) -> Dict:
    """Test secuencial I/O-bound"""
    print("üêå TEST SECUENCIAL (I/O-bound)")
    start = time.time()
    
    results = []
    for task in tasks:
        result = simulate_io_task_sync(task, 1.0)
        results.append(result)
    
    duration = time.time() - start
    print(f"‚è±Ô∏è Tiempo secuencial: {duration:.2f}s")
    
    return {
        'method': 'sequential',
        'time': duration,
        'results': results
    }

def test_threading_io(tasks: List[str]) -> Dict:
    """Test threading I/O-bound"""
    print("üßµ TEST THREADING (I/O-bound)")
    start = time.time()
    
    with concurrent.futures.ThreadPoolExecutor(max_workers=5) as executor:
        futures = [executor.submit(simulate_io_task_thread, task, 1.0) for task in tasks]
        results = [future.result() for future in futures]
    
    duration = time.time() - start
    print(f"‚è±Ô∏è Tiempo threading: {duration:.2f}s")
    
    return {
        'method': 'threading', 
        'time': duration,
        'results': results
    }

async def test_async_io(tasks: List[str]) -> Dict:
    """Test async I/O-bound"""
    print("‚ö° TEST ASYNC (I/O-bound)")
    start = time.time()
    
    async_tasks = [simulate_io_task_async(task, 1.0) for task in tasks]
    results = await asyncio.gather(*async_tasks)
    
    duration = time.time() - start
    print(f"‚è±Ô∏è Tiempo async: {duration:.2f}s")
    
    return {
        'method': 'async',
        'time': duration, 
        'results': results
    }

def test_sequential_cpu(ranges: List[tuple]) -> Dict:
    """Test secuencial CPU-bound"""
    print("üêå TEST SECUENCIAL (CPU-bound)")
    start = time.time()
    
    results = []
    for start_range, end_range in ranges:
        result = count_primes_in_range(start_range, end_range)
        results.append(result)
    
    duration = time.time() - start
    print(f"‚è±Ô∏è Tiempo secuencial: {duration:.2f}s")
    
    return {
        'method': 'sequential',
        'time': duration,
        'results': results
    }

def test_threading_cpu(ranges: List[tuple]) -> Dict:
    """Test threading CPU-bound"""
    print("üßµ TEST THREADING (CPU-bound)")
    start = time.time()
    
    with concurrent.futures.ThreadPoolExecutor(max_workers=mp.cpu_count()) as executor:
        futures = [executor.submit(count_primes_in_range, start_r, end_r) for start_r, end_r in ranges]
        results = [future.result() for future in futures]
    
    duration = time.time() - start
    print(f"‚è±Ô∏è Tiempo threading: {duration:.2f}s")
    
    return {
        'method': 'threading',
        'time': duration,
        'results': results
    }

def test_multiprocessing_cpu(ranges: List[tuple]) -> Dict:
    """Test multiprocessing CPU-bound"""
    print("üî• TEST MULTIPROCESSING (CPU-bound)")
    start = time.time()
    
    with mp.Pool(processes=mp.cpu_count()) as pool:
        results = pool.starmap(count_primes_in_range, ranges)
    
    duration = time.time() - start
    print(f"‚è±Ô∏è Tiempo multiprocessing: {duration:.2f}s")
    
    return {
        'method': 'multiprocessing',
        'time': duration,
        'results': results
    }

# ============================================================================
# üéØ PARTE 4: GU√çAS DE DECISI√ìN PR√ÅCTICA
# ============================================================================

def show_decision_matrix():
    """Mostrar matriz de decisi√≥n clara"""
    print("\nüéØ" + "="*70)
    print("üéØ PARTE 4: GU√çA DE DECISI√ìN PR√ÅCTICA")
    print("="*70)
    
    print("\nüìã MATRIZ DE DECISI√ìN:")
    print("="*50)
    
    scenarios = [
        # (Escenario, Recomendaci√≥n, Raz√≥n, Ejemplo)
        ("üåê Web Server (1000+ requests)", "‚ö° ASYNC", "Escalabilidad masiva", "FastAPI, aiohttp"),
        ("üï∑Ô∏è Web Scraping (1000+ URLs)", "‚ö° ASYNC", "Muchas requests HTTP", "aiohttp + BeautifulSoup"),
        ("üìÅ Procesamiento archivos (50)", "üßµ THREADING", "I/O moderado", "Leer/procesar archivos"),
        ("üéÆ Game server (10,000 players)", "‚ö° ASYNC", "Muchas conexiones", "WebSockets masivos"),
        ("üî¢ C√°lculo matem√°tico intensivo", "üî• MULTIPROCESSING", "CPU-bound puro", "Cient√≠fico, ML"),
        ("üí¨ Chat server (1000+ users)", "‚ö° ASYNC", "WebSockets m√∫ltiples", "Discord, Slack"),
        ("üìä ETL de datos (100 archivos)", "üßµ THREADING", "I/O + l√≥gica", "Pandas, transformaciones"),
        ("üé® Renderizado 3D", "üî• MULTIPROCESSING", "CPU intensivo", "Blender, ray tracing"),
    ]
    
    for scenario, recommendation, reason, example in scenarios:
        print(f"\n{scenario}")
        print(f"   üëç Usar: {recommendation}")
        print(f"   üí° Raz√≥n: {reason}")
        print(f"   üìù Ejemplo: {example}")

def show_performance_rules():
    """Mostrar reglas de rendimiento"""
    print("\n‚ö° REGLAS DE RENDIMIENTO:")
    print("="*40)
    
    print("\nüî• Para CPU-bound (c√°lculos intensivos):")
    print("   ü•á Multiprocessing: ~10x speedup")
    print("   ü•à Sequential: baseline")  
    print("   ü•â Threading: ~1x (GIL)")
    print("   ü•â Async: ~1x (un solo thread)")
    
    print("\nüíΩ Para I/O-bound (red, disco, DB):")
    print("   ü•á Async: ~10x+ speedup, memoria m√≠nima")
    print("   ü•à Threading: ~10x speedup, m√°s memoria")
    print("   ü•â Multiprocessing: funciona pero overhead")
    print("   ü•â Sequential: ~1x baseline")

def show_resource_usage():
    """Mostrar uso de recursos"""
    print("\nüíæ USO DE RECURSOS:")
    print("="*30)
    
    print("\nüìä Memoria por unidad:")
    print("   üßµ Threading: ~8MB por thread")
    print("   ‚ö° Async: ~1KB por corrutina") 
    print("   üî• Multiprocessing: ~10-50MB por proceso")
    
    print("\nüéØ L√≠mites pr√°cticos:")
    print("   üßµ Threading: ~5,000 threads")
    print("   ‚ö° Async: ~100,000+ corrutinas")
    print("   üî• Multiprocessing: ~CPU cores")

# ============================================================================
# üé™ DEMOSTRACI√ìN PRINCIPAL
# ============================================================================

async def run_complete_demonstration():
    """Ejecutar demostraci√≥n completa"""
    print("‚ö°" + "="*70)
    print("‚ö° GU√çA COMPLETA: Threading vs Multiprocessing vs Async")
    print("="*70)
    
    # Parte 1: Conceptos fundamentales
    explain_paradigm_difference()
    demo_scalability_difference()
    
    # Parte 2: Race conditions
    demonstrate_threading_race_conditions()
    await demonstrate_async_no_race_conditions()
    explain_why_async_is_safe()
    
    # Parte 3: Comparaci√≥n de rendimiento I/O-bound
    print("\nüìä COMPARACI√ìN I/O-BOUND:")
    print("="*40)
    
    tasks = ["url1", "url2", "url3", "url4", "url5"]
    
    # Sequential
    seq_result = test_sequential_io(tasks)
    
    # Threading
    thread_result = test_threading_io(tasks)
    
    # Async
    async_result = await test_async_io(tasks)
    
    # An√°lisis I/O-bound
    print(f"\nüìà AN√ÅLISIS I/O-BOUND:")
    seq_time = seq_result['time']
    thread_time = thread_result['time']
    async_time = async_result['time']
    
    print(f"üßµ Threading speedup: {seq_time/thread_time:.1f}x")
    print(f"‚ö° Async speedup: {seq_time/async_time:.1f}x")
    print(f"üí° GANADOR I/O-bound: Threading/Async (similar rendimiento)")
    
    # Parte 4: Comparaci√≥n CPU-bound
    print("\nüìä COMPARACI√ìN CPU-bound:")
    print("="*40)
    
    ranges = [
        (1000000, 1100000),  # ~8000 primos cada rango
        (1100001, 1200000),
        (1200001, 1300000),
        (1300001, 1400000)
    ]
    
    # Sequential
    seq_cpu = test_sequential_cpu(ranges)
    
    # Threading  
    thread_cpu = test_threading_cpu(ranges)
    
    # Multiprocessing
    mp_cpu = test_multiprocessing_cpu(ranges)
    
    # An√°lisis CPU-bound
    print(f"\nüìà AN√ÅLISIS CPU-BOUND:")
    seq_time = seq_cpu['time']
    thread_time = thread_cpu['time']
    mp_time = mp_cpu['time']
    
    print(f"üßµ Threading speedup: {seq_time/thread_time:.1f}x")
    print(f"üî• Multiprocessing speedup: {seq_time/mp_time:.1f}x")
    print(f"üí° GANADOR CPU-bound: Multiprocessing (~{mp.cpu_count()}x cores)")
    
    # Parte 5: Gu√≠as de decisi√≥n
    show_decision_matrix()
    show_performance_rules()
    show_resource_usage()
    
    # Conclusi√≥n
    print("\nüéì" + "="*60)
    print("üéì CONCLUSI√ìN FINAL")
    print("="*60)
    print("‚ö° Async NO es 'mejor' que Threading en general")
    print("üéØ Cada herramienta tiene su lugar ESPEC√çFICO:")
    print("   üï∑Ô∏è Async ‚Üí I/O masivo (web servers, scraping)")
    print("   üßµ Threading ‚Üí I/O moderado (archivos, APIs)")
    print("   üî• Multiprocessing ‚Üí CPU intensivo (c√°lculos)")
    print("\nüí° La clave est√° en elegir la herramienta correcta!")
    print("üìö Ahora tienes el conocimiento para decidir sabiamente")

def main():
    """Funci√≥n principal"""
    try:
        asyncio.run(run_complete_demonstration())
    except KeyboardInterrupt:
        print("\nüëã Demostraci√≥n interrumpida por el usuario")
    except Exception as e:
        print(f"\n‚ùå Error durante la demostraci√≥n: {e}")

if __name__ == "__main__":
    main() 