"""
‚öñÔ∏è SESI√ìN 2.4: Gu√≠a de Comparaci√≥n - Threading vs Multiprocessing vs Async

Esta gu√≠a completa te ayuda a decidir cu√°ndo usar cada enfoque de concurrencia
basado en el tipo de problema, recursos del sistema y requisitos de rendimiento.

üéØ Objetivos:
- Comparar Threading, Multiprocessing y Async
- Entender cu√°ndo usar cada uno
- Ver ejemplos pr√°cticos de cada enfoque
- Crear una gu√≠a de decisi√≥n clara
"""

import time
import threading
import multiprocessing as mp
import asyncio
import concurrent.futures
import requests
import math
from typing import List, Dict

# ============================================================================
# üß™ TAREA DE PRUEBA 1: I/O-bound (Descargas de URLs)
# ============================================================================

def download_url_sync(url: str) -> Dict:
    """Descarga s√≠ncrona de URL"""
    try:
        response = requests.get(url, timeout=3)
        return {
            'url': url,
            'status': response.status_code,
            'size': len(response.content),
            'method': 'sync'
        }
    except Exception as e:
        return {
            'url': url,
            'error': str(e),
            'method': 'sync'
        }

def test_sequential_io(urls: List[str]) -> Dict:
    """Test secuencial para I/O-bound"""
    print("üêå TEST SECUENCIAL (I/O-bound)")
    start = time.time()
    
    results = []
    for url in urls:
        result = download_url_sync(url)
        results.append(result)
    
    duration = time.time() - start
    print(f"‚è±Ô∏è Tiempo secuencial: {duration:.2f}s")
    
    return {
        'method': 'sequential',
        'time': duration,
        'results': results
    }

def test_threading_io(urls: List[str]) -> Dict:
    """Test threading para I/O-bound"""
    print("üßµ TEST THREADING (I/O-bound)")
    start = time.time()
    
    with concurrent.futures.ThreadPoolExecutor(max_workers=4) as executor:
        results = list(executor.map(download_url_sync, urls))
    
    duration = time.time() - start
    print(f"‚è±Ô∏è Tiempo threading: {duration:.2f}s")
    
    return {
        'method': 'threading',
        'time': duration,
        'results': results
    }

def test_multiprocessing_io(urls: List[str]) -> Dict:
    """Test multiprocessing para I/O-bound (no recomendado)"""
    print("üî• TEST MULTIPROCESSING (I/O-bound - overhead innecesario)")
    start = time.time()
    
    with concurrent.futures.ProcessPoolExecutor(max_workers=4) as executor:
        results = list(executor.map(download_url_sync, urls))
    
    duration = time.time() - start
    print(f"‚è±Ô∏è Tiempo multiprocessing: {duration:.2f}s")
    
    return {
        'method': 'multiprocessing',
        'time': duration,
        'results': results
    }

async def download_url_async(url: str) -> Dict:
    """Descarga as√≠ncrona de URL"""
    import aiohttp
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(url, timeout=3) as response:
                content = await response.read()
                return {
                    'url': url,
                    'status': response.status,
                    'size': len(content),
                    'method': 'async'
                }
    except Exception as e:
        return {
            'url': url,
            'error': str(e),
            'method': 'async'
        }

async def test_async_io(urls: List[str]) -> Dict:
    """Test async para I/O-bound"""
    print("‚ö° TEST ASYNC (I/O-bound)")
    start = time.time()
    
    tasks = [download_url_async(url) for url in urls]
    results = await asyncio.gather(*tasks)
    
    duration = time.time() - start
    print(f"‚è±Ô∏è Tiempo async: {duration:.2f}s")
    
    return {
        'method': 'async',
        'time': duration,
        'results': results
    }

# ============================================================================
# üß™ TAREA DE PRUEBA 2: CPU-bound (C√°lculo de primos)
# ============================================================================

def is_prime_cpu(n: int) -> bool:
    """Funci√≥n CPU-intensiva para calcular primos"""
    if n < 2:
        return False
    if n == 2:
        return True
    if n % 2 == 0:
        return False
    
    for i in range(3, int(math.sqrt(n)) + 1, 2):
        if n % i == 0:
            return False
    return True

def count_primes_in_range(start: int, end: int) -> int:
    """Cuenta primos en un rango"""
    count = 0
    for n in range(start, end + 1):
        if is_prime_cpu(n):
            count += 1
    return count

def test_sequential_cpu(ranges: List[tuple]) -> Dict:
    """Test secuencial para CPU-bound"""
    print("üêå TEST SECUENCIAL (CPU-bound)")
    start = time.time()
    
    results = []
    for start_range, end_range in ranges:
        count = count_primes_in_range(start_range, end_range)
        results.append(count)
    
    duration = time.time() - start
    total_primes = sum(results)
    print(f"‚è±Ô∏è Tiempo secuencial: {duration:.2f}s - {total_primes} primos")
    
    return {
        'method': 'sequential',
        'time': duration,
        'primes': total_primes,
        'results': results
    }

def test_threading_cpu(ranges: List[tuple]) -> Dict:
    """Test threading para CPU-bound (limitado por GIL)"""
    print("üßµ TEST THREADING (CPU-bound - limitado por GIL)")
    start = time.time()
    
    with concurrent.futures.ThreadPoolExecutor(max_workers=4) as executor:
        futures = [executor.submit(count_primes_in_range, start_range, end_range) 
                  for start_range, end_range in ranges]
        results = [future.result() for future in futures]
    
    duration = time.time() - start
    total_primes = sum(results)
    print(f"‚è±Ô∏è Tiempo threading: {duration:.2f}s - {total_primes} primos")
    
    return {
        'method': 'threading',
        'time': duration,
        'primes': total_primes,
        'results': results
    }

def test_multiprocessing_cpu(ranges: List[tuple]) -> Dict:
    """Test multiprocessing para CPU-bound (recomendado)"""
    print("üî• TEST MULTIPROCESSING (CPU-bound - verdadero paralelismo)")
    start = time.time()
    
    with concurrent.futures.ProcessPoolExecutor(max_workers=mp.cpu_count()) as executor:
        futures = [executor.submit(count_primes_in_range, start_range, end_range) 
                  for start_range, end_range in ranges]
        results = [future.result() for future in futures]
    
    duration = time.time() - start
    total_primes = sum(results)
    print(f"‚è±Ô∏è Tiempo multiprocessing: {duration:.2f}s - {total_primes} primos")
    
    return {
        'method': 'multiprocessing',
        'time': duration,
        'primes': total_primes,
        'results': results
    }

# ============================================================================
# üìä COMPARACIONES COMPLETAS
# ============================================================================

def compare_io_bound():
    """Comparar todos los m√©todos para I/O-bound"""
    print("\n" + "üìä" + "="*70)
    print("üìä COMPARACI√ìN COMPLETA: I/O-BOUND (Descargas)")
    print("="*70)
    
    # URLs de prueba (simulamos con httpbin)
    urls = [
        "https://httpbin.org/delay/1",
        "https://httpbin.org/delay/1", 
        "https://httpbin.org/delay/1",
        "https://httpbin.org/delay/1"
    ]
    
    print(f"üéØ Tarea: Descargar {len(urls)} URLs con delay de 1s cada una")
    print(f"‚è±Ô∏è Tiempo esperado secuencial: ~{len(urls)} segundos")
    print(f"‚è±Ô∏è Tiempo esperado concurrente: ~1 segundo")
    
    results = {}
    
    # Test secuencial
    try:
        results['sequential'] = test_sequential_io(urls)
    except Exception as e:
        print(f"‚ùå Error en test secuencial: {e}")
        results['sequential'] = {'method': 'sequential', 'time': float('inf')}
    
    # Test threading
    try:
        results['threading'] = test_threading_io(urls)
    except Exception as e:
        print(f"‚ùå Error en test threading: {e}")
        results['threading'] = {'method': 'threading', 'time': float('inf')}
    
    # Test multiprocessing
    try:
        results['multiprocessing'] = test_multiprocessing_io(urls)
    except Exception as e:
        print(f"‚ùå Error en test multiprocessing: {e}")
        results['multiprocessing'] = {'method': 'multiprocessing', 'time': float('inf')}
    
    # Test async (comentado porque requiere aiohttp)
    print("‚ö° TEST ASYNC: Requiere 'pip install aiohttp' - omitido")
    
    # An√°lisis de resultados
    print(f"\nüìà AN√ÅLISIS I/O-BOUND:")
    seq_time = results['sequential']['time']
    thread_time = results['threading']['time']
    mp_time = results['multiprocessing']['time']
    
    if thread_time < float('inf'):
        thread_speedup = seq_time / thread_time
        print(f"üßµ Threading speedup: {thread_speedup:.1f}x")
        
    if mp_time < float('inf'):
        mp_speedup = seq_time / mp_time
        print(f"üî• Multiprocessing speedup: {mp_speedup:.1f}x")
    
    print(f"\nüí° CONCLUSI√ìN I/O-BOUND:")
    print(f"ü•á GANADOR: Threading/Async (menor overhead)")
    print(f"ü•à Segundo: Multiprocessing (funciona pero overhead innecesario)")
    print(f"ü•â √öltimo: Secuencial (bloquea en cada I/O)")
    
    return results

def compare_cpu_bound():
    """Comparar todos los m√©todos para CPU-bound"""
    print("\n" + "üìä" + "="*70)
    print("üìä COMPARACI√ìN COMPLETA: CPU-BOUND (C√°lculo de primos)")
    print("="*70)
    
    # Rangos de prueba
    ranges = [
        (10000, 12000),  # ~200 primos cada rango
        (12001, 14000),
        (14001, 16000),
        (16001, 18000)
    ]
    
    print(f"üéØ Tarea: Contar primos en {len(ranges)} rangos")
    print(f"üíª CPU cores disponibles: {mp.cpu_count()}")
    print(f"‚è±Ô∏è Speedup te√≥rico m√°ximo: ~{mp.cpu_count()}x")
    
    results = {}
    
    # Test secuencial
    results['sequential'] = test_sequential_cpu(ranges)
    
    # Test threading
    results['threading'] = test_threading_cpu(ranges)
    
    # Test multiprocessing  
    results['multiprocessing'] = test_multiprocessing_cpu(ranges)
    
    # An√°lisis de resultados
    print(f"\nüìà AN√ÅLISIS CPU-BOUND:")
    seq_time = results['sequential']['time']
    thread_time = results['threading']['time']
    mp_time = results['multiprocessing']['time']
    
    thread_speedup = seq_time / thread_time
    mp_speedup = seq_time / mp_time
    
    print(f"üßµ Threading speedup: {thread_speedup:.1f}x")
    print(f"üî• Multiprocessing speedup: {mp_speedup:.1f}x")
    
    efficiency = (mp_speedup / mp.cpu_count()) * 100
    print(f"üìä Eficiencia multiprocessing: {efficiency:.1f}%")
    
    print(f"\nüí° CONCLUSI√ìN CPU-BOUND:")
    print(f"ü•á GANADOR: Multiprocessing (verdadero paralelismo)")
    print(f"ü•à Segundo: Threading (limitado por GIL, ~1x speedup)")
    print(f"ü•â √öltimo: Secuencial (usa solo 1 core)")
    
    return results

# ============================================================================
# üéì GU√çA DE DECISI√ìN
# ============================================================================

def decision_guide():
    """Gu√≠a completa para decidir qu√© usar"""
    print("\n" + "üéì" + "="*70)
    print("üéì GU√çA DE DECISI√ìN: ¬øQU√â USAR CU√ÅNDO?")
    print("="*70)
    
    scenarios = {
        "I/O-bound": {
            "description": "Red, archivos, base de datos",
            "threading": "ü•á EXCELENTE - Ideal para I/O",
            "multiprocessing": "ü•à FUNCIONA - Overhead innecesario", 
            "async": "ü•á EXCELENTE - Muy eficiente para I/O",
            "examples": ["API calls", "File downloads", "Database queries"]
        },
        "CPU-bound": {
            "description": "C√°lculos, algoritmos, procesamiento",
            "threading": "ü•â MALO - Limitado por GIL",
            "multiprocessing": "ü•á EXCELENTE - Verdadero paralelismo",
            "async": "ü•â MALO - Un solo thread",
            "examples": ["Image processing", "Mathematical calculations", "Data analysis"]
        },
        "Mixed workload": {
            "description": "Combinaci√≥n de I/O y CPU",
            "threading": "ü•à BUENO - Para partes I/O",
            "multiprocessing": "ü•á MEJOR - Para partes CPU",
            "async": "ü•à BUENO - Para partes I/O",
            "examples": ["Web scraping + processing", "ETL pipelines"]
        }
    }
    
    for scenario, details in scenarios.items():
        print(f"\nüéØ ESCENARIO: {scenario.upper()}")
        print(f"   üìù {details['description']}")
        print(f"   üßµ Threading: {details['threading']}")
        print(f"   üî• Multiprocessing: {details['multiprocessing']}")
        print(f"   ‚ö° Async: {details['async']}")
        print(f"   üí° Ejemplos: {', '.join(details['examples'])}")

def resource_requirements():
    """Comparar requerimientos de recursos"""
    print("\n" + "üíª" + "="*60)
    print("üíª REQUERIMIENTOS DE RECURSOS")
    print("="*60)
    
    resources = {
        "Threading": {
            "memory": "Bajo (memoria compartida)",
            "cpu": "Limitado por GIL para CPU-bound",
            "overhead": "Bajo",
            "scalability": "Buena para I/O, mala para CPU"
        },
        "Multiprocessing": {
            "memory": "Alto (cada proceso tiene su memoria)",
            "cpu": "Excelente (usa todos los cores)",
            "overhead": "Alto (IPC, serializaci√≥n)",
            "scalability": "Excelente para CPU-bound"
        },
        "Async": {
            "memory": "Muy bajo (un solo thread)",
            "cpu": "Un solo core",
            "overhead": "Muy bajo",
            "scalability": "Excelente para I/O concurrente"
        }
    }
    
    for method, reqs in resources.items():
        print(f"\nüîß {method}:")
        for resource, description in reqs.items():
            print(f"   {resource.capitalize()}: {description}")

def practical_recommendations():
    """Recomendaciones pr√°cticas"""
    print("\n" + "üí°" + "="*60)
    print("üí° RECOMENDACIONES PR√ÅCTICAS")
    print("="*60)
    
    recommendations = [
        ("üåê Web APIs", "Threading o Async", "I/O-bound, muchas requests"),
        ("üßÆ Procesamiento de datos", "Multiprocessing", "CPU-intensivo"),
        ("üìÅ Procesamiento de archivos", "Threading", "I/O + algo de CPU"),
        ("üéÆ Videojuegos", "Threading", "UI responsiva + l√≥gica"),
        ("ü§ñ Machine Learning", "Multiprocessing", "C√°lculos paralelos"),
        ("üï∑Ô∏è Web Scraping", "Async > Threading", "Muchas requests HTTP"),
        ("üìä Data Analysis", "Multiprocessing", "Pandas, NumPy paralelo"),
        ("üîÑ Background tasks", "Threading", "No bloquear UI principal")
    ]
    
    for use_case, recommendation, reason in recommendations:
        print(f"{use_case:25} ‚Üí {recommendation:20} ({reason})")

def common_pitfalls():
    """Errores comunes a evitar"""
    print("\n" + "‚ö†Ô∏è" + "="*60)
    print("‚ö†Ô∏è ERRORES COMUNES A EVITAR")
    print("="*60)
    
    pitfalls = [
        "üö´ Threading para CPU-bound intensivo",
        "üö´ Multiprocessing para I/O simple", 
        "üö´ Olvidar locks en threading",
        "üö´ No usar context managers (with statements)",
        "üö´ Demasiados threads/procesos (overhead)",
        "üö´ No manejar excepciones en workers",
        "üö´ Mixing async y sync sin cuidado",
        "üö´ No cerrar recursos adecuadamente"
    ]
    
    for pitfall in pitfalls:
        print(f"   {pitfall}")

# ============================================================================
# üß™ DEMOSTRACI√ìN PRINCIPAL
# ============================================================================

def run_complete_comparison():
    """Ejecutar comparaci√≥n completa"""
    print("‚öñÔ∏è COMPARACI√ìN COMPLETA: Threading vs Multiprocessing vs Async")
    print("üéØ Objetivo: Entender cu√°ndo usar cada enfoque")
    
    print(f"\nüíª INFORMACI√ìN DEL SISTEMA:")
    print(f"üî¢ CPU cores: {mp.cpu_count()}")
    print(f"üßµ Threading disponible: ‚úÖ")
    print(f"üî• Multiprocessing disponible: ‚úÖ")
    print(f"‚ö° Async disponible: ‚úÖ")
    
    # Comparaciones
    io_results = compare_io_bound()
    cpu_results = compare_cpu_bound()
    
    # Gu√≠as
    decision_guide()
    resource_requirements()
    practical_recommendations()
    common_pitfalls()
    
    return {
        'io_results': io_results,
        'cpu_results': cpu_results
    }

if __name__ == "__main__":
    print("‚öñÔ∏è GU√çA COMPLETA: Threading vs Multiprocessing vs Async")
    print("üéØ OBJETIVO: Decidir cu√°l usar en cada situaci√≥n")
    
    print("\nüéØ ¬øQu√© quieres ver?")
    print("1. Comparaci√≥n completa (I/O + CPU)")
    print("2. Solo comparaci√≥n I/O-bound")
    print("3. Solo comparaci√≥n CPU-bound")
    print("4. Solo gu√≠as de decisi√≥n")
    choice = input("üëâ Opci√≥n (1-4): ").strip()
    
    if choice == "1":
        # Comparaci√≥n completa
        run_complete_comparison()
        
    elif choice == "2":
        # Solo I/O
        compare_io_bound()
        decision_guide()
        
    elif choice == "3":
        # Solo CPU
        compare_cpu_bound()
        decision_guide()
        
    else:
        # Solo gu√≠as
        decision_guide()
        resource_requirements()
        practical_recommendations()
        common_pitfalls()
    
    print("\n‚úÖ ¬°GU√çA DE COMPARACI√ìN COMPLETADA!")
    print("üéì Ahora sabes cu√°ndo usar Threading, Multiprocessing o Async")
    print("üöÄ ¬°SESI√ìN 2 COMPLETADA!")
    print("üéâ Has dominado: Threading ‚Üí Multiprocessing ‚Üí IPC ‚Üí Comparaci√≥n") 